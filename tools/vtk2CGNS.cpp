// Include VTK stuff
#include <vtkSmartPointer.h>
#include <vtkUnstructuredGridReader.h>
#include <vtkUnstructuredGrid.h>
#include <vtkCellIterator.h>
#include <vtkIdList.h>
// Include CGNS stuff
#include "cgnslib.h"
// Include C++ stuff
#include <string>
#include <iostream>
#include <map>
#include <memory>

using namespace std;

struct Point2D {
  double x;
  double y;
};

struct Cell {
  int points[3];
};

int main(int argc, char **argv) {
  // Read in VTK file generated by Gmsh
  string fileName = "naca0012.vtk";
  vtkSmartPointer<vtkUnstructuredGrid> grid;
  auto reader = vtkSmartPointer<vtkUnstructuredGridReader>::New();
  reader->SetFileName (fileName.c_str());
  reader->Update();
  grid = reader->GetOutput();

  map<int,unique_ptr<Point2D>> pointMap;
  map<int,unique_ptr<Cell>> cellMap;
  map<int,unique_ptr<Cell>> boundaryCellMap;

  // Iterate over cells
  vtkSmartPointer<vtkCellIterator> cellIterator = grid->NewCellIterator();
  while(!cellIterator->IsDoneWithTraversal()) {
    // Check that this is a cell (not a line or point)
    // only an issue due to how Gmsh generates the VTK file
    if(cellIterator->GetNumberOfPoints() == 3) {
      vtkSmartPointer<vtkIdList> ids = cellIterator->GetPointIds();
      // Add points to pointMap if it does not already contain the point
      for(int i = 0; i < 3; i++) {
        if(pointMap.count(ids->GetId(i)) == 0) {
          double coords[3];
          grid->GetPoint(ids->GetId(i), coords);
          unique_ptr<Point2D> point = make_unique<Point2D>();
          point->x = coords[0];
          point->y = coords[1];
          pointMap.insert(pair<int,unique_ptr<Point2D>>(ids->GetId(i), move(point)));
        }
      }
      unique_ptr<Cell> cell = make_unique<Cell>();
      cell->points[0] = ids->GetId(0);
      cell->points[1] = ids->GetId(1);
      cell->points[2] = ids->GetId(2);
      cellMap.insert(pair<int,unique_ptr<Cell>>(cellIterator->GetCellId(), move(cell)));
    }
    // Go to next cell
    cellIterator->GoToNextCell();
  }

  cout << "Number of points: " << pointMap.size() << endl;
  cout << "Number of cell: " << cellMap.size() << endl;

  // Write out CGNS file
  int file;
  if (cg_open("naca0012.cgns", CG_MODE_WRITE, &file)) {
    cg_error_exit();
  }

  // Create base
  string baseName = "Base";
  int cellDim = 2;
  int physicalDim = 2;
  int baseIndex;
  cg_base_write(file, baseName.c_str(), cellDim, physicalDim, &baseIndex);
  // Create zone
  string zoneName = "Zone 0";
  int sizes[3];
  // Number of vertices
  sizes[0] = pointMap.size();
  // Number of cells
  sizes[1] = cellMap.size();
  // Number of boundary vertices (zero if elements not sorted)
  sizes[2] = 0;
  int zoneIndex;
  cg_zone_write(file, baseIndex, zoneName.c_str(), sizes,
                CGNS_ENUMV(Unstructured), &zoneIndex);
  // Write grid coordinates
  double *x = (double *)malloc(sizes[0] * sizeof(double));
  double *y = (double *)malloc(sizes[0] * sizeof(double));
  for(auto const &point : pointMap) {
    int index = point.first;
    x[index] = point.second->x;
    y[index] = point.second->y;
  }
  int coordIndex;
  cg_coord_write(file, baseIndex, zoneIndex, CGNS_ENUMV(RealDouble),
                 "CoordinateX", x, &coordIndex);
  cg_coord_write(file, baseIndex, zoneIndex, CGNS_ENUMV(RealDouble),
                 "CoordinateY", y, &coordIndex);

  cg_close(file);

  free(x);
  free(y);
}
