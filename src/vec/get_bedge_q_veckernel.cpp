//
// auto-generated by op2.py
//

//user function
inline void get_bedge_q(const int *bedge_type, const int *bedgeNum,
                        const double *nx, const double *ny,
                        const double *q, double *exteriorQ) {
  int exInd = 0;
  int nInd = 0;
  if(*bedgeNum == 1) {
    exInd = 4 * 5;
    nInd = 5;
  } else if(*bedgeNum == 2) {
    exInd = 2 * 4 * 5;
    nInd = 2 * 5;
  }

  int *fmask;

  if(*bedgeNum == 0) {
    fmask = FMASK;
  } else if(*bedgeNum == 1) {
    fmask = &FMASK[5];
  } else {
    fmask = &FMASK[2 * 5];
  }

  if(*bedge_type == 0) {
    // Inflow
    for(int i = 0; i < 5; i++) {
      exteriorQ[exInd + i * 4]     += bc_r;
      exteriorQ[exInd + i * 4 + 1] += bc_r * bc_u;
      // exteriorQ[exInd + i * 4 + 2] += 0.0;
      exteriorQ[exInd + i * 4 + 3] += bc_e;
    }
  } else if(*bedge_type == 1) {
    // Outflow
    for(int i = 0; i < 5; i++) {
      int qInd = fmask[i] * 4;
      exteriorQ[exInd + i * 4]     += bc_r;
      exteriorQ[exInd + i * 4 + 1] += bc_r * bc_u;
      // exteriorQ[exInd + i * 4 + 2] += 0.0;
      exteriorQ[exInd + i * 4 + 3] += q[qInd + 3];
    }
  } else {
    // Wall
    for(int i = 0; i < 5; i++) {
      int qInd = fmask[i] * 4;
      exteriorQ[exInd + i * 4]     += q[qInd];
      exteriorQ[exInd + i * 4 + 1] += q[qInd + 1] - 2 * (nx[nInd + i] * q[qInd + 1] + ny[nInd + i] * q[qInd + 2]) * nx[nInd + i];
      exteriorQ[exInd + i * 4 + 2] += q[qInd + 2] - 2 * (nx[nInd + i] * q[qInd + 1] + ny[nInd + i] * q[qInd + 2]) * ny[nInd + i];
      // exteriorQ[exInd + i * 4 + 1] += q[qInd + 1] - (nx[nInd + i] * q[qInd + 1] + ny[nInd + i] * q[qInd + 2]) * nx[nInd + i];
      // exteriorQ[exInd + i * 4 + 2] += q[qInd + 2] - (nx[nInd + i] * q[qInd + 1] + ny[nInd + i] * q[qInd + 2]) * ny[nInd + i];
      exteriorQ[exInd + i * 4 + 3] += q[qInd + 3];
    }
  }
}
#ifdef VECTORIZE
//user function -- modified for vectorisation
#if defined __clang__ || defined __GNUC__
__attribute__((always_inline))
#endif
inline void get_bedge_q_vec( const int bedge_type[][SIMD_VEC], const int bedgeNum[][SIMD_VEC], const double nx[][SIMD_VEC], const double ny[][SIMD_VEC], const double q[][SIMD_VEC], double exteriorQ[][SIMD_VEC], int idx ) {
  int exInd = 0;
  int nInd = 0;
  if(bedgeNum[0][idx]== 1) {
    exInd = 4 * 5;
    nInd = 5;
  } else if(bedgeNum[0][idx]== 2) {
    exInd = 2 * 4 * 5;
    nInd = 2 * 5;
  }

  int *fmask;

  if(bedgeNum[0][idx]== 0) {
    fmask = FMASK;
  } else if(bedgeNum[0][idx]== 1) {
    fmask = &FMASK[5];
  } else {
    fmask = &FMASK[2 * 5];
  }

  if(bedge_type[0][idx]== 0) {

    for(int i = 0; i < 5; i++) {
      exteriorQ[exInd + i * 4][idx]     += bc_r;
      exteriorQ[exInd + i * 4 + 1][idx] += bc_r * bc_u;

      exteriorQ[exInd + i * 4 + 3][idx] += bc_e;
    }
  } else if(bedge_type[0][idx]== 1) {

    for(int i = 0; i < 5; i++) {
      int qInd = fmask[i] * 4;
      exteriorQ[exInd + i * 4][idx]     += bc_r;
      exteriorQ[exInd + i * 4 + 1][idx] += bc_r * bc_u;

      exteriorQ[exInd + i * 4 + 3][idx] += q[qInd + 3][idx];
    }
  } else {

    for(int i = 0; i < 5; i++) {
      int qInd = fmask[i] * 4;
      exteriorQ[exInd + i * 4][idx]     += q[qInd][idx];
      exteriorQ[exInd + i * 4 + 1][idx] += q[qInd + 1][idx] - 2 * (nx[nInd + i][idx] * q[qInd + 1][idx] + ny[nInd + i][idx] * q[qInd + 2][idx]) * nx[nInd + i][idx];
      exteriorQ[exInd + i * 4 + 2][idx] += q[qInd + 2][idx] - 2 * (nx[nInd + i][idx] * q[qInd + 1][idx] + ny[nInd + i][idx] * q[qInd + 2][idx]) * ny[nInd + i][idx];


      exteriorQ[exInd + i * 4 + 3][idx] += q[qInd + 3][idx];
    }
  }

}
#endif

// host stub function
void op_par_loop_get_bedge_q(char const *name, op_set set,
  op_arg arg0,
  op_arg arg1,
  op_arg arg2,
  op_arg arg3,
  op_arg arg4,
  op_arg arg5){

  int nargs = 6;
  op_arg args[6];

  args[0] = arg0;
  args[1] = arg1;
  args[2] = arg2;
  args[3] = arg3;
  args[4] = arg4;
  args[5] = arg5;
  //create aligned pointers for dats
  ALIGNED_int const int * __restrict__ ptr0 = (int *) arg0.data;
  DECLARE_PTR_ALIGNED(ptr0,int_ALIGN);
  ALIGNED_int const int * __restrict__ ptr1 = (int *) arg1.data;
  DECLARE_PTR_ALIGNED(ptr1,int_ALIGN);
  ALIGNED_double const double * __restrict__ ptr2 = (double *) arg2.data;
  DECLARE_PTR_ALIGNED(ptr2,double_ALIGN);
  ALIGNED_double const double * __restrict__ ptr3 = (double *) arg3.data;
  DECLARE_PTR_ALIGNED(ptr3,double_ALIGN);
  ALIGNED_double const double * __restrict__ ptr4 = (double *) arg4.data;
  DECLARE_PTR_ALIGNED(ptr4,double_ALIGN);
  ALIGNED_double       double * __restrict__ ptr5 = (double *) arg5.data;
  DECLARE_PTR_ALIGNED(ptr5,double_ALIGN);

  // initialise timers
  double cpu_t1, cpu_t2, wall_t1, wall_t2;
  op_timing_realloc(5);
  op_timers_core(&cpu_t1, &wall_t1);

  if (OP_diags>2) {
    printf(" kernel routine with indirection: get_bedge_q\n");
  }

  int exec_size = op_mpi_halo_exchanges(set, nargs, args);

  if (exec_size >0) {

    #ifdef VECTORIZE
    #pragma novector
    for ( int n=0; n<(exec_size/SIMD_VEC)*SIMD_VEC; n+=SIMD_VEC ){
      if ((n+SIMD_VEC >= set->core_size) && (n+SIMD_VEC-set->core_size < SIMD_VEC)) {
        op_mpi_wait_all(nargs, args);
      }
      ALIGNED_int int dat0[1][SIMD_VEC];
      ALIGNED_int int dat1[1][SIMD_VEC];
      ALIGNED_double double dat2[15][SIMD_VEC];
      ALIGNED_double double dat3[15][SIMD_VEC];
      ALIGNED_double double dat4[60][SIMD_VEC];
      ALIGNED_double double dat5[60][SIMD_VEC];
      #pragma omp simd simdlen(SIMD_VEC)
      for ( int i=0; i<SIMD_VEC; i++ ){
        int idx0_1 = 1 * (n+i);
        int idx1_1 = 1 * (n+i);
        int idx2_15 = 15 * arg2.map_data[(n+i) * arg2.map->dim + 0];
        int idx3_15 = 15 * arg2.map_data[(n+i) * arg2.map->dim + 0];
        int idx4_60 = 60 * arg2.map_data[(n+i) * arg2.map->dim + 0];
        int idx5_60 = 60 * arg2.map_data[(n+i) * arg2.map->dim + 0];

        dat0[0][i] = (ptr0)[idx0_1 + 0];

        dat1[0][i] = (ptr1)[idx1_1 + 0];

        dat2[0][i] = (ptr2)[idx2_15 + 0];
        dat2[1][i] = (ptr2)[idx2_15 + 1];
        dat2[2][i] = (ptr2)[idx2_15 + 2];
        dat2[3][i] = (ptr2)[idx2_15 + 3];
        dat2[4][i] = (ptr2)[idx2_15 + 4];
        dat2[5][i] = (ptr2)[idx2_15 + 5];
        dat2[6][i] = (ptr2)[idx2_15 + 6];
        dat2[7][i] = (ptr2)[idx2_15 + 7];
        dat2[8][i] = (ptr2)[idx2_15 + 8];
        dat2[9][i] = (ptr2)[idx2_15 + 9];
        dat2[10][i] = (ptr2)[idx2_15 + 10];
        dat2[11][i] = (ptr2)[idx2_15 + 11];
        dat2[12][i] = (ptr2)[idx2_15 + 12];
        dat2[13][i] = (ptr2)[idx2_15 + 13];
        dat2[14][i] = (ptr2)[idx2_15 + 14];

        dat3[0][i] = (ptr3)[idx3_15 + 0];
        dat3[1][i] = (ptr3)[idx3_15 + 1];
        dat3[2][i] = (ptr3)[idx3_15 + 2];
        dat3[3][i] = (ptr3)[idx3_15 + 3];
        dat3[4][i] = (ptr3)[idx3_15 + 4];
        dat3[5][i] = (ptr3)[idx3_15 + 5];
        dat3[6][i] = (ptr3)[idx3_15 + 6];
        dat3[7][i] = (ptr3)[idx3_15 + 7];
        dat3[8][i] = (ptr3)[idx3_15 + 8];
        dat3[9][i] = (ptr3)[idx3_15 + 9];
        dat3[10][i] = (ptr3)[idx3_15 + 10];
        dat3[11][i] = (ptr3)[idx3_15 + 11];
        dat3[12][i] = (ptr3)[idx3_15 + 12];
        dat3[13][i] = (ptr3)[idx3_15 + 13];
        dat3[14][i] = (ptr3)[idx3_15 + 14];

        dat4[0][i] = (ptr4)[idx4_60 + 0];
        dat4[1][i] = (ptr4)[idx4_60 + 1];
        dat4[2][i] = (ptr4)[idx4_60 + 2];
        dat4[3][i] = (ptr4)[idx4_60 + 3];
        dat4[4][i] = (ptr4)[idx4_60 + 4];
        dat4[5][i] = (ptr4)[idx4_60 + 5];
        dat4[6][i] = (ptr4)[idx4_60 + 6];
        dat4[7][i] = (ptr4)[idx4_60 + 7];
        dat4[8][i] = (ptr4)[idx4_60 + 8];
        dat4[9][i] = (ptr4)[idx4_60 + 9];
        dat4[10][i] = (ptr4)[idx4_60 + 10];
        dat4[11][i] = (ptr4)[idx4_60 + 11];
        dat4[12][i] = (ptr4)[idx4_60 + 12];
        dat4[13][i] = (ptr4)[idx4_60 + 13];
        dat4[14][i] = (ptr4)[idx4_60 + 14];
        dat4[15][i] = (ptr4)[idx4_60 + 15];
        dat4[16][i] = (ptr4)[idx4_60 + 16];
        dat4[17][i] = (ptr4)[idx4_60 + 17];
        dat4[18][i] = (ptr4)[idx4_60 + 18];
        dat4[19][i] = (ptr4)[idx4_60 + 19];
        dat4[20][i] = (ptr4)[idx4_60 + 20];
        dat4[21][i] = (ptr4)[idx4_60 + 21];
        dat4[22][i] = (ptr4)[idx4_60 + 22];
        dat4[23][i] = (ptr4)[idx4_60 + 23];
        dat4[24][i] = (ptr4)[idx4_60 + 24];
        dat4[25][i] = (ptr4)[idx4_60 + 25];
        dat4[26][i] = (ptr4)[idx4_60 + 26];
        dat4[27][i] = (ptr4)[idx4_60 + 27];
        dat4[28][i] = (ptr4)[idx4_60 + 28];
        dat4[29][i] = (ptr4)[idx4_60 + 29];
        dat4[30][i] = (ptr4)[idx4_60 + 30];
        dat4[31][i] = (ptr4)[idx4_60 + 31];
        dat4[32][i] = (ptr4)[idx4_60 + 32];
        dat4[33][i] = (ptr4)[idx4_60 + 33];
        dat4[34][i] = (ptr4)[idx4_60 + 34];
        dat4[35][i] = (ptr4)[idx4_60 + 35];
        dat4[36][i] = (ptr4)[idx4_60 + 36];
        dat4[37][i] = (ptr4)[idx4_60 + 37];
        dat4[38][i] = (ptr4)[idx4_60 + 38];
        dat4[39][i] = (ptr4)[idx4_60 + 39];
        dat4[40][i] = (ptr4)[idx4_60 + 40];
        dat4[41][i] = (ptr4)[idx4_60 + 41];
        dat4[42][i] = (ptr4)[idx4_60 + 42];
        dat4[43][i] = (ptr4)[idx4_60 + 43];
        dat4[44][i] = (ptr4)[idx4_60 + 44];
        dat4[45][i] = (ptr4)[idx4_60 + 45];
        dat4[46][i] = (ptr4)[idx4_60 + 46];
        dat4[47][i] = (ptr4)[idx4_60 + 47];
        dat4[48][i] = (ptr4)[idx4_60 + 48];
        dat4[49][i] = (ptr4)[idx4_60 + 49];
        dat4[50][i] = (ptr4)[idx4_60 + 50];
        dat4[51][i] = (ptr4)[idx4_60 + 51];
        dat4[52][i] = (ptr4)[idx4_60 + 52];
        dat4[53][i] = (ptr4)[idx4_60 + 53];
        dat4[54][i] = (ptr4)[idx4_60 + 54];
        dat4[55][i] = (ptr4)[idx4_60 + 55];
        dat4[56][i] = (ptr4)[idx4_60 + 56];
        dat4[57][i] = (ptr4)[idx4_60 + 57];
        dat4[58][i] = (ptr4)[idx4_60 + 58];
        dat4[59][i] = (ptr4)[idx4_60 + 59];

        dat5[0][i] = (ptr5)[idx5_60 + 0];
        dat5[1][i] = (ptr5)[idx5_60 + 1];
        dat5[2][i] = (ptr5)[idx5_60 + 2];
        dat5[3][i] = (ptr5)[idx5_60 + 3];
        dat5[4][i] = (ptr5)[idx5_60 + 4];
        dat5[5][i] = (ptr5)[idx5_60 + 5];
        dat5[6][i] = (ptr5)[idx5_60 + 6];
        dat5[7][i] = (ptr5)[idx5_60 + 7];
        dat5[8][i] = (ptr5)[idx5_60 + 8];
        dat5[9][i] = (ptr5)[idx5_60 + 9];
        dat5[10][i] = (ptr5)[idx5_60 + 10];
        dat5[11][i] = (ptr5)[idx5_60 + 11];
        dat5[12][i] = (ptr5)[idx5_60 + 12];
        dat5[13][i] = (ptr5)[idx5_60 + 13];
        dat5[14][i] = (ptr5)[idx5_60 + 14];
        dat5[15][i] = (ptr5)[idx5_60 + 15];
        dat5[16][i] = (ptr5)[idx5_60 + 16];
        dat5[17][i] = (ptr5)[idx5_60 + 17];
        dat5[18][i] = (ptr5)[idx5_60 + 18];
        dat5[19][i] = (ptr5)[idx5_60 + 19];
        dat5[20][i] = (ptr5)[idx5_60 + 20];
        dat5[21][i] = (ptr5)[idx5_60 + 21];
        dat5[22][i] = (ptr5)[idx5_60 + 22];
        dat5[23][i] = (ptr5)[idx5_60 + 23];
        dat5[24][i] = (ptr5)[idx5_60 + 24];
        dat5[25][i] = (ptr5)[idx5_60 + 25];
        dat5[26][i] = (ptr5)[idx5_60 + 26];
        dat5[27][i] = (ptr5)[idx5_60 + 27];
        dat5[28][i] = (ptr5)[idx5_60 + 28];
        dat5[29][i] = (ptr5)[idx5_60 + 29];
        dat5[30][i] = (ptr5)[idx5_60 + 30];
        dat5[31][i] = (ptr5)[idx5_60 + 31];
        dat5[32][i] = (ptr5)[idx5_60 + 32];
        dat5[33][i] = (ptr5)[idx5_60 + 33];
        dat5[34][i] = (ptr5)[idx5_60 + 34];
        dat5[35][i] = (ptr5)[idx5_60 + 35];
        dat5[36][i] = (ptr5)[idx5_60 + 36];
        dat5[37][i] = (ptr5)[idx5_60 + 37];
        dat5[38][i] = (ptr5)[idx5_60 + 38];
        dat5[39][i] = (ptr5)[idx5_60 + 39];
        dat5[40][i] = (ptr5)[idx5_60 + 40];
        dat5[41][i] = (ptr5)[idx5_60 + 41];
        dat5[42][i] = (ptr5)[idx5_60 + 42];
        dat5[43][i] = (ptr5)[idx5_60 + 43];
        dat5[44][i] = (ptr5)[idx5_60 + 44];
        dat5[45][i] = (ptr5)[idx5_60 + 45];
        dat5[46][i] = (ptr5)[idx5_60 + 46];
        dat5[47][i] = (ptr5)[idx5_60 + 47];
        dat5[48][i] = (ptr5)[idx5_60 + 48];
        dat5[49][i] = (ptr5)[idx5_60 + 49];
        dat5[50][i] = (ptr5)[idx5_60 + 50];
        dat5[51][i] = (ptr5)[idx5_60 + 51];
        dat5[52][i] = (ptr5)[idx5_60 + 52];
        dat5[53][i] = (ptr5)[idx5_60 + 53];
        dat5[54][i] = (ptr5)[idx5_60 + 54];
        dat5[55][i] = (ptr5)[idx5_60 + 55];
        dat5[56][i] = (ptr5)[idx5_60 + 56];
        dat5[57][i] = (ptr5)[idx5_60 + 57];
        dat5[58][i] = (ptr5)[idx5_60 + 58];
        dat5[59][i] = (ptr5)[idx5_60 + 59];

      }
      #pragma omp simd simdlen(SIMD_VEC)
      for ( int i=0; i<SIMD_VEC; i++ ){
        get_bedge_q_vec(
          dat0,
          dat1,
          dat2,
          dat3,
          dat4,
          dat5,
          i);
      }
      for ( int i=0; i<SIMD_VEC; i++ ){
        int idx5_60 = 60 * arg2.map_data[(n+i) * arg2.map->dim + 0];

        (ptr5)[idx5_60 + 0] = dat5[0][i];
        (ptr5)[idx5_60 + 1] = dat5[1][i];
        (ptr5)[idx5_60 + 2] = dat5[2][i];
        (ptr5)[idx5_60 + 3] = dat5[3][i];
        (ptr5)[idx5_60 + 4] = dat5[4][i];
        (ptr5)[idx5_60 + 5] = dat5[5][i];
        (ptr5)[idx5_60 + 6] = dat5[6][i];
        (ptr5)[idx5_60 + 7] = dat5[7][i];
        (ptr5)[idx5_60 + 8] = dat5[8][i];
        (ptr5)[idx5_60 + 9] = dat5[9][i];
        (ptr5)[idx5_60 + 10] = dat5[10][i];
        (ptr5)[idx5_60 + 11] = dat5[11][i];
        (ptr5)[idx5_60 + 12] = dat5[12][i];
        (ptr5)[idx5_60 + 13] = dat5[13][i];
        (ptr5)[idx5_60 + 14] = dat5[14][i];
        (ptr5)[idx5_60 + 15] = dat5[15][i];
        (ptr5)[idx5_60 + 16] = dat5[16][i];
        (ptr5)[idx5_60 + 17] = dat5[17][i];
        (ptr5)[idx5_60 + 18] = dat5[18][i];
        (ptr5)[idx5_60 + 19] = dat5[19][i];
        (ptr5)[idx5_60 + 20] = dat5[20][i];
        (ptr5)[idx5_60 + 21] = dat5[21][i];
        (ptr5)[idx5_60 + 22] = dat5[22][i];
        (ptr5)[idx5_60 + 23] = dat5[23][i];
        (ptr5)[idx5_60 + 24] = dat5[24][i];
        (ptr5)[idx5_60 + 25] = dat5[25][i];
        (ptr5)[idx5_60 + 26] = dat5[26][i];
        (ptr5)[idx5_60 + 27] = dat5[27][i];
        (ptr5)[idx5_60 + 28] = dat5[28][i];
        (ptr5)[idx5_60 + 29] = dat5[29][i];
        (ptr5)[idx5_60 + 30] = dat5[30][i];
        (ptr5)[idx5_60 + 31] = dat5[31][i];
        (ptr5)[idx5_60 + 32] = dat5[32][i];
        (ptr5)[idx5_60 + 33] = dat5[33][i];
        (ptr5)[idx5_60 + 34] = dat5[34][i];
        (ptr5)[idx5_60 + 35] = dat5[35][i];
        (ptr5)[idx5_60 + 36] = dat5[36][i];
        (ptr5)[idx5_60 + 37] = dat5[37][i];
        (ptr5)[idx5_60 + 38] = dat5[38][i];
        (ptr5)[idx5_60 + 39] = dat5[39][i];
        (ptr5)[idx5_60 + 40] = dat5[40][i];
        (ptr5)[idx5_60 + 41] = dat5[41][i];
        (ptr5)[idx5_60 + 42] = dat5[42][i];
        (ptr5)[idx5_60 + 43] = dat5[43][i];
        (ptr5)[idx5_60 + 44] = dat5[44][i];
        (ptr5)[idx5_60 + 45] = dat5[45][i];
        (ptr5)[idx5_60 + 46] = dat5[46][i];
        (ptr5)[idx5_60 + 47] = dat5[47][i];
        (ptr5)[idx5_60 + 48] = dat5[48][i];
        (ptr5)[idx5_60 + 49] = dat5[49][i];
        (ptr5)[idx5_60 + 50] = dat5[50][i];
        (ptr5)[idx5_60 + 51] = dat5[51][i];
        (ptr5)[idx5_60 + 52] = dat5[52][i];
        (ptr5)[idx5_60 + 53] = dat5[53][i];
        (ptr5)[idx5_60 + 54] = dat5[54][i];
        (ptr5)[idx5_60 + 55] = dat5[55][i];
        (ptr5)[idx5_60 + 56] = dat5[56][i];
        (ptr5)[idx5_60 + 57] = dat5[57][i];
        (ptr5)[idx5_60 + 58] = dat5[58][i];
        (ptr5)[idx5_60 + 59] = dat5[59][i];

      }
    }

    //remainder
    for ( int n=(exec_size/SIMD_VEC)*SIMD_VEC; n<exec_size; n++ ){
    #else
    for ( int n=0; n<exec_size; n++ ){
    #endif
      if (n==set->core_size) {
        op_mpi_wait_all(nargs, args);
      }
      int map2idx;
      map2idx = arg2.map_data[n * arg2.map->dim + 0];

      get_bedge_q(
        &(ptr0)[1 * n],
        &(ptr1)[1 * n],
        &(ptr2)[15 * map2idx],
        &(ptr3)[15 * map2idx],
        &(ptr4)[60 * map2idx],
        &(ptr5)[60 * map2idx]);
    }
  }

  if (exec_size == 0 || exec_size == set->core_size) {
    op_mpi_wait_all(nargs, args);
  }
  // combine reduction data
  op_mpi_set_dirtybit(nargs, args);

  // update kernel record
  op_timers_core(&cpu_t2, &wall_t2);
  OP_kernels[5].name      = name;
  OP_kernels[5].count    += 1;
  OP_kernels[5].time     += wall_t2 - wall_t1;
  OP_kernels[5].transfer += (float)set->size * arg2.size;
  OP_kernels[5].transfer += (float)set->size * arg3.size;
  OP_kernels[5].transfer += (float)set->size * arg4.size;
  OP_kernels[5].transfer += (float)set->size * arg5.size * 2.0f;
  OP_kernels[5].transfer += (float)set->size * arg0.size;
  OP_kernels[5].transfer += (float)set->size * arg1.size;
  OP_kernels[5].transfer += (float)set->size * arg2.map->dim * 4.0f;
}
